== Cohesion metrics

=== LCOM - Lack of Cohesion in Methods

////
Hohe LCOM-Werte indizieren Substrukturen, welche nicht in Verbindung zueinander stehen, und somit eher getrennt werden sollten.
Während diese Metrik hauptsächlich auf Klassenebene berechnet wird, ist derselbe Mechanismus auch auf höheren Abstraktionsebenen wie Packages, Modulen oder Microservices anwendbar.
////

==== What means LCOM?

LCOM measures the number of "connected components" in a class.
A connected component is a set of related methods (and class-level variables).
There should be only one connected component in one class.
If there are 2 or more components, the class should be split into several smaller classes.

* `LCOM = 1`: The class is a solid component with all methods and fields related.
* `LCOM > 1`: The class can be split into different classes.
* `LCOM = 0`: The class has no methods.

According to the single responsibility principle, a class should provide a single component with all methods and fields related.
This is the case when LCOM is exactly 1.
Otherwise, the class lacks of cohesion.

But pay attention to the purpose of the class.
Sometimes there are classes, that contain only utility methods, e.g. https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/util/StringUtils.html[StringUtils].
This is completely ok, because all methods are static and they don't belong to one or more fields.
That means it hasn't any connected components.
In this case the LCOM is 0.

IMPORTANT: How to handle methods that don't read or write a field? +
Has to be distinguished between static vs non-static, final vs non-final? +
What role has the visibility?

==== Example

The example show a class with three connected components.
It could be split into 3 classes.

.What means LCOM?
image::Cohesion_what_means_LCOM.png[Class with LCOM=3]

==== How to calculate LCOM with Neo4J?

===== Overview

The process to calculate LCOM is divided into several steps:

1. <<create_a_group_for_each_field>>
2. <<connect_each_method_to_the_respective_group>>
3. <<merge_groups_with_a_common_method>>
4. <<count_and_assign_the_number_of_groups>>

===== Detailed explanation

.Set the stage

Assume a class ist given as described in the diagram below.

[[assume_given_class]]
.Assume the given class
image::00_Cohesion_given_class_LCOM.png[Step 0: Assume the given class]

.Create groups and assign they to the respective fields and methods

The first step is to create an extra node for each field.
This new node will be given the label "Group" and the name of the field as name.
Each field will be connected to the respective group node by a relationship called "belongs-to".

[[create_a_group_for_each_field]]
.Create a group for each field
image::01_Cohesion_create_groups_LCOM.png[Step 1: Create a group for each field]

In the next step, all methods that depends either directly or indirectly on a field will be linked to the group node.

[[connect_each_method_to_the_respective_group]]
.Connect each method to the respective group
image::02_Cohesion_connect_methods_to_groups_LCOM.png[Step 2: Connect each method to the respective group]

The previous two steps (<<create_a_group_for_each_field>>, <<connect_each_method_to_the_respective_group>>) are combined in one Cypher statement:

[[cohesion-metrics:LcomCreateGroups]]
.Creates a group for each field and assigns the field and their accessing methods to the group and the group to the class
[source,cypher,role=concept]
----
MATCH (c:Java:Class)-[:DECLARES]->(f:Field) WHERE f.static IS NULL
WITH c, collect(f) AS fields
OPTIONAL MATCH (c)-[:DECLARES]->(m:Method) WHERE m.static IS NULL
WITH c, fields, collect(m) AS methods
UNWIND fields AS field
MERGE (c)-[:HAS_GROUP]->(g:Group {name:field.name, group:true})-[:BELONGS_TO]->(field)
WITH c, methods, field, g
UNWIND methods AS method
MATCH (method)-[:READS|WRITES*1..]->(field)
MERGE (g)-[:BELONGS_TO]->(method)
WITH c, methods, field, g
MATCH (method)-[:INVOKES*1..]->(:Method)-[:READS|WRITES*1..]->(field)
MERGE (g)-[:BELONGS_TO]->(method)
RETURN g
----

.Merge group nodes

Then, all methods or fields that are linked to more than one group will be merged to one group node.

[[merge_groups_with_a_common_method]]
.Merge groups having at least one common field or common method
image::03_Merge_groups_with_a_common_method_LCOM.png[Step 3: Merge groups with a common method]

The Cypher statement for <<merge_groups_with_a_common_method>> is quite simple.
The challenge is, that it requires the https://neo4j-contrib.github.io/neo4j-apoc-procedures/[APOC library].

[quote, APOC User Guide]
The APOC library consists of many (about 450) procedures and functions to help with many different tasks in areas like data integration, graph algorithms or data conversion.

[[cohesion-metrics:LcomMergeGroups]]
.Merges all groups that belong to one shared field or method
[source,cypher,role=concept,requiresConcepts="cohesion-metrics:LcomCreateGroups"]
----
MATCH (c:Java:Class)-[:DECLARES]->(m:Method) WHERE m.static IS NULL
WITH c, collect(m) AS methods
UNWIND methods AS method
MATCH path=(g1:Group)-[:BELONGS_TO]->(method)<-[:BELONGS_TO]-(g2:Group) WHERE g1<>g2
WITH c, methods, filter(aNode IN nodes(path) WHERE aNode.group = true) AS groups
CALL apoc.refactor.mergeNodes(groups, {properties:"combine", mergeRels:true}) YIELD node
RETURN c
----

// Missing step: Is it necessary to delete duplicate relationships?

.Count group nodes

Last, the remaining group nodes will be counted and the result will be added as a new property called "lcom" of the class.

[[count_and_assign_the_number_of_groups]]
.Count the remaining groups and assign the result to a property of the type
image::04_Count_and_assign_the_number_of_groups_LCOM.png[Step 4: Count and assign the number of groups]

The last step <<count_and_assign_the_number_of_groups>> extends the existing data model.
This step is useful to simplify further Cypher queries, e.g. to find the classes with a `LCOM > 1`.

[[cohesion-metrics:Lcom]]
.Counts the groups per class and sets the attribute lcom
[source,cypher,role=concept,requiresConcepts="cohesion-metrics:LcomMergeGroups"]
----
MATCH (c:Java:Class)-[:HAS_GROUP]->(g:Group)
WITH c, count(DISTINCT g) AS lcom
SET c.lcom = lcom
RETURN c
----

=== COP - Cohesion in types of packages

==== What means package cohesion?

This metric is very similar to "<<What means LCOM?>>", but it isn't on class level, but on package level.
This metric measures the number of "connected components" in a package.
A connected component is a set of coherent classes and interfaces inside a package.
There should be only one connected component in one package.
If there are 2 or more connected components, the package should be divided into several smaller packages.

==== Example

The example show a package with three connected components.
It could be split into 3 packages.

.What means cohesion of a package?
image::Cohesion_what_means_cohesion_of_a_package.png[Package with cohesion=3]

==== How to calculate CohP with Neo4J?

===== Overview

===== Detailed explanation

[[cohesion-metrics:CohpCreateGroups]]
.Creates a group for each type and assigns the type to the group and the group to the package.
[source,cypher,role=concept]
----
MATCH (p:Java:Package)-[:CONTAINS]->(t:Java:Type)
WITH p, collect(t) AS types
UNWIND types AS type MERGE (p)-[:HAS_GROUP]->(g:Group {name:type.name, group:true})-[:BELONGS_TO]->(type)
WITH p, g, type
MATCH (p)-[:CONTAINS]->(t:Java:Type)-[:DEPENDS_ON*1..]->(type) MERGE (g)-[:BELONGS_TO]->(t)
RETURN g
----

[[cohesion-metrics:CohpMergeGroups]]
.Merges groups with at least one shared type.
[source,cypher,role=concept,requiresConcepts="cohesion-metrics:CohpCreateGroups"]
----
MATCH (p:Java:Package)-[:CONTAINS]->(t:Java:Type)
WITH p, collect(t) AS types
UNWIND types AS type
MATCH path=(g1:Group)-[:BELONGS_TO]->(type)<-[:BELONGS_TO]-(g2:Group) WHERE g1<>g2
WITH p, types, filter(aNode in nodes(path) WHERE aNode.group = true) AS groups
CALL apoc.refactor.mergeNodes(groups, {properties:"combine", mergeRels:true}) YIELD node
RETURN p
----

[[cohesion-metrics:Cohp]]
.Counts groups per package and sets the attribute cohp.
[source,cypher,role=concept,requiresConcepts="cohesion-metrics:CohpMergeGroups"]
----
MATCH (p:Java:Package)-[:HAS_GROUP]->(g:Group)
WITH p, count(DISTINCT g) AS cohp
SET p.cohp = cohp
RETURN p
----

=== Resources

1. abc
