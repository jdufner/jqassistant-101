== Cohesion metrics

=== LCOM - Lack of Cohesion in Methods

////
Hohe LCOM-Werte indizieren Substrukturen, welche nicht in Verbindung zueinander stehen, und somit eher getrennt werden sollten.
Während diese Metrik hauptsächlich auf Klassenebene berechnet wird, ist derselbe Mechanismus auch auf höheren Abstraktionsebenen wie Packages, Modulen oder Microservices anwendbar.
////

LCOM measures the number of "connected components" in a class.
A connected component is a set of related methods (and class-level variables).
There should be only one such a component in each class.
If there are 2 or more components, the class should be split into so many smaller classes.

* `LCOM = 1`: The class is a solid component with all methods and fields related.
* `LCOM > 1`: The class can be split to different classes.
* `LCOM = 0`: The class has no methods.

According to the single responsibility principle, a class should provide a single component with all methods and fields related.
This is the case when LCOM is exactly 1.
Otherwise, the class lacks of cohesion.
But pay attention to the purpose of the class.
Sometimes there are classes, that contain only utility methods, e.g. https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/util/StringUtils.html[StringUtils].
This is completely ok, because all methods are static and they don't belong to one or more fields.
That means they haven't any connected components.

==== Example

.What means LCOM?
image::Cohesion_what_means_LCOM.png[Class with LCOM=3]

==== How to calculate LCOM?

To create groups of connected components a group for each field has to be to created.

.Create a group for each field
image::Cohesion_create_groups_LCOM.png[Step 1: Create a group for each field]

[[cohesion-metrics:LcomCreateGroups]]
.Creates a group for each field and assigns the field to the group and the group to the class.
[source,cypher,role=concept]
----
MATCH (c:Java:Class)-[:DECLARES]->(f:Field) WHERE f.static IS NULL
WITH c, collect(f) AS fields
OPTIONAL MATCH (c)-[:DECLARES]->(m:Method) WHERE m.static IS NULL
WITH c, fields, collect(m) AS methods
UNWIND fields AS field
MERGE (c)-[:HAS_GROUP]->(g:Group {name:field.name, group:true})-[:BELONGS_TO]->(field)
WITH c, methods, field, g
UNWIND methods AS method
MATCH (method)-[:READS|WRITES*1..]->(field)
MERGE (g)-[:BELONGS_TO]->(method)
WITH c, methods, field, g
MATCH (method)-[:INVOKES*1..]->(:Method)-[:READS|WRITES*1..]->(field)
MERGE (g)-[:BELONGS_TO]->(method)
RETURN g
----

[[cohesion-metrics:LcomMergeGroups]]
.Merges all groups that belong to one shared field or method.
[source,cypher,role=concept,requiresConcepts="cohesion-metrics:LcomCreateGroups"]
----
MATCH (c:Java:Class)-[:DECLARES]->(m:Method) WHERE m.static IS NULL
WITH c, collect(m) AS methods
UNWIND methods AS method
MATCH path=(g1:Group)-[:BELONGS_TO]->(method)<-[:BELONGS_TO]-(g2:Group) WHERE g1<>g2
WITH c, methods, filter(aNode IN nodes(path) WHERE aNode.group = true) AS groups
CALL apoc.refactor.mergeNodes(groups, {properties:"combine", mergeRels:true}) YIELD node
RETURN c
----

TODO: Delete duplicate relationships!

[[cohesion-metrics:Lcom]]
.Counts the groups per class and sets the attribute lcom4.
[source,cypher,role=concept,requiresConcepts="cohesion-metrics:LcomMergeGroups"]
----
MATCH (c:Java:Class)-[:HAS_GROUP]->(g:Group)
WITH c, count(DISTINCT g) AS lcom
SET c.lcom = lcom
RETURN c
----

==== Example


=== CohP - package level cohesion metric

Computes a package level cohesion metric

[[cohesion-metrics:CohpCreateGroups]]
.Creates a group for each type and assigns the type to the group and the group to the package.
[source,cypher,role=concept]
----
MATCH (p:Java:Package)-[:CONTAINS]->(t:Java:Type)
WITH p, collect(t) AS types
UNWIND types AS type MERGE (p)-[:HAS_GROUP]->(g:Group {name:type.name, group:true})-[:BELONGS_TO]->(type)
WITH p, g, type
MATCH (p)-[:CONTAINS]->(t:Java:Type)-[:DEPENDS_ON*1..]->(type) MERGE (g)-[:BELONGS_TO]->(t)
RETURN g
----

[[cohesion-metrics:CohpMergeGroups]]
.Merges groups with at least one shared type.
[source,cypher,role=concept,requiresConcepts="cohesion-metrics:CohpCreateGroups"]
----
MATCH (p:Java:Package)-[:CONTAINS]->(t:Java:Type)
WITH p, collect(t) AS types
UNWIND types AS type
MATCH path=(g1:Group)-[:BELONGS_TO]->(type)<-[:BELONGS_TO]-(g2:Group) WHERE g1<>g2
WITH p, types, filter(aNode in nodes(path) WHERE aNode.group = true) AS groups
CALL apoc.refactor.mergeNodes(groups, {properties:"combine", mergeRels:true}) YIELD node
RETURN p
----

[[cohesion-metrics:Cohp]]
.Counts groups per package and sets the attribute cohp.
[source,cypher,role=concept,requiresConcepts="cohesion-metrics:CohpMergeGroups"]
----
MATCH (p:Java:Package)-[:HAS_GROUP]->(g:Group)
WITH p, count(DISTINCT g) AS cohp
SET p.cohp = cohp
RETURN p
----

==== Example


=== Resources

1. abc
