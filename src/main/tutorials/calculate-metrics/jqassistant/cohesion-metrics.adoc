== Cohesion metrics

=== LCOM - Lack of Cohesion in Methods

////
Hohe LCOM-Werte indizieren Substrukturen, welche nicht in Verbindung zueinander stehen, und somit eher getrennt werden sollten.
Während diese Metrik hauptsächlich auf Klassenebene berechnet wird, ist derselbe Mechanismus auch auf höheren Abstraktionsebenen wie Packages, Modulen oder Microservices anwendbar.
////

LCOM4 measures the number of "connected components" in a class.
A connected component is a set of related methods (and class-level variables).
There should be only one such a component in each class.
If there are 2 or more components, the class should be split into so many smaller classes.

* LCOM4 = 1: The class is a solid component with all methods and fields related
* LCOM4 > 1: The class can be split to different classes
* LCOM4 = 0: The class has no methods

According to the single responsibility principle, a class should provide a single component with all methods and fields related.
This is the case when LCOM4 = 1.
Otherwise, the class lacks of cohesion.

[[lcom4-metrics:createGroups]]
.Computes LCOM4
[source,cypher,role=concept]
----
MATCH (c:Java:Class)-[:DECLARES]->(f:Field) WHERE f.static IS NULL
WITH c, collect(f) AS fields
OPTIONAL MATCH (c)-[:DECLARES]->(m:Method) WHERE m.static IS NULL
WITH c, fields, collect(m) AS methods
UNWIND fields AS field
MERGE (c)-[:HAS_GROUP]->(g:Group {name:field.name, group:true})-[:BELONGS_TO]->(field)
WITH c, methods, field, g
UNWIND methods AS method
MATCH (method)-[:READS|WRITES*1..]->(field)
MERGE (g)-[:BELONGS_TO]->(method)
WITH c, methods, field, g
MATCH (method)-[:INVOKES*1..]->(:Method)-[:READS|WRITES*1..]->(field)
MERGE (g)-[:BELONGS_TO]->(method)
RETURN g
----

[[lcom4-metrics:mergeGroups]]
.Computes LCOM4
[source,cypher,role=concept,requiresConcepts="lcom4-metrics:createGroups"]
----
MATCH (c:Java:Class)-[:DECLARES]->(m:Method) WHERE m.static IS NULL
WITH c, collect(m) AS methods
UNWIND methods AS method
MATCH p=(g1:Group)-[:BELONGS_TO]->(method)<-[:BELONGS_TO]-(g2:Group) WHERE g1<>g2
WITH c, methods, filter(oneNode IN nodes(p) WHERE oneNode.group = true) AS groups
CALL apoc.refactor.mergeNodes(groups, {properties:"combine", mergeRels:true}) YIELD node
RETURN c
----

[[lcom4-metrics:Lcom4]]
.Computes LCOM4
[source,cypher,role=concept,requiresConcepts="lcom4-metrics:mergeGroups"]
----
MATCH (c:Java:Class)-[:HAS_GROUP]->(g:Group)
WITH c, count(distinct g) AS lcom4
SET c.lcom4 = lcom4
RETURN c
----

==== Example

==== Test

[[lcom4-metrics:Lcom4Clazz1]]
.Computes LCOM4 of Clazz1
[source,cypher,role=concept,requiresConcepts="lcom4-metrics:Lcom4",severity=major]
----
MATCH (c:Java:Class {fqn:"your.project.lcom.a.Clazz1", lcom4:1})
RETURN c
----

[[lcom4-metrics:Lcom4Clazz2]]
.Computes LCOM4 of Clazz2
[source,cypher,role=concept,requiresConcepts="lcom4-metrics:Lcom4",severity=major]
----
MATCH (c:Java:Class {fqn:"your.project.lcom.a.Clazz2", lcom4:1})
RETURN c
----

[[lcom4-metrics:Lcom4Clazz3]]
.Computes LCOM4 of Clazz3
[source,cypher,role=concept,requiresConcepts="lcom4-metrics:Lcom4",severity=major]
----
MATCH (c:Java:Class {fqn:"your.project.lcom.a.Clazz3", lcom4:2})
RETURN c
----

[[lcom4-metrics:LcomTests]]
[role=group,includesConcepts="lcom4-metrics:Lcom4Clazz1,lcom4-metrics:Lcom4Clazz2,lcom4-metrics:Lcom4Clazz3"]

=== CohP - package level cohesion metric

[[lcom4-metrics:Cohp]]
.Computes a package level cohesion metric
[source,cypher,role=concept]
----
MATCH (p:Java:Package)-[:CONTAINS]->(t:Java:Type)
RETURN p
----

Erzeuge für jeden Typ eine Gruppe und ordne jedem Typ und deren abhängigen Typen eine Gruppe zu

````
MATCH (p:Java:Package {fqn:"your.project.lcom.b"})-[:CONTAINS]->(t:Java:Type)
WITH p, collect(t) AS types
UNWIND types AS type MERGE (p)-[:HAS_GROUP]->(g:Group {name:type.name, group:true})-[:BELONGS_TO]->(type)
WITH p, g, type
MATCH (t:Type)-[:DEPENDS_ON*1..]->(type) MERGE (g)-[:BELONGS_TO]->(t)
RETURN g
````

Führe Gruppen zusammen, die mindestens einen gemeinsamen Typen haben.

`MATCH (p:Java:Package {fqn:"your.project.lcom.b"})-[:CONTAINS]->(t:Java:Type) WITH p, collect(t) AS types UNWIND types AS type MATCH path=(g1:Group)-[:BELONGS_TO]->(type)<-[:BELONGS_TO]-(g2:Group) WHERE g1<>g2 AND id(g1)<id(g2) WITH p, types, filter(aNode in nodes(path) WHERE aNode.group = true) AS groups CALL apoc.refactor.mergeNodes(groups, {properties:"combine", mergeRels:true}) YIELD node RETURN p`

==== Example

==== Test

[[lcom4-metrics:CohpTests]]
[role=group,includesConcepts="lcom4-metrics:Cohp"]

After the last concept, constraint or group has to stand a heading or text.

=== Resources

1. abc
