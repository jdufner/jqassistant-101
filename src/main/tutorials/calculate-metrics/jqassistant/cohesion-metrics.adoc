== Cohesion metrics

=== LCOM - Lack of Cohesion in Methods

////
Hohe LCOM-Werte indizieren Substrukturen, welche nicht in Verbindung zueinander stehen, und somit eher getrennt werden sollten.
Während diese Metrik hauptsächlich auf Klassenebene berechnet wird, ist derselbe Mechanismus auch auf höheren Abstraktionsebenen wie Packages, Modulen oder Microservices anwendbar.
////

==== What means LCOM?

LCOM measures the number of "connected components" in a class.
A connected component is a set of related methods (and class-level variables).
There should be only one such a component in each class.
If there are 2 or more components, the class should be split into so many smaller classes.

* `LCOM = 1`: The class is a solid component with all methods and fields related.
* `LCOM > 1`: The class can be split into different classes.
* `LCOM = 0`: The class has no methods.

According to the single responsibility principle, a class should provide a single component with all methods and fields related.
This is the case when LCOM is exactly 1.
Otherwise, the class lacks of cohesion.
But pay attention to the purpose of the class.
Sometimes there are classes, that contain only utility methods, e.g. https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/util/StringUtils.html[StringUtils].
This is completely ok, because all methods are static and they don't belong to one or more fields.
That means they haven't any connected components.

==== Example

.What means LCOM?
image::Cohesion_what_means_LCOM.png[Class with LCOM=3]

==== How to calculate LCOM?

The process to calculate LCOM is divided into several steps:

1. <<create_a_group_for_each_field>>
2. <<connect_each_method_to_the_respective_group>>
3. <<merge_groups_with_a_common_method>>
4. <<count_and_assign_the_number_of_groups>>

[[create_a_group_for_each_field]]
.Create a group for each field
image::01_Cohesion_create_groups_LCOM.png[Step 1: Create a group for each field]

[[connect_each_method_to_the_respective_group]]
.Connect each method to the respective group
image::02_Cohesion_connect_methods_to_groups_LCOM.png[Step 2: Connect each method to the respective group]

[[merge_groups_with_a_common_method]]
.Merge group having at least one field or method common method
image::03_Merge_groups_with_a_common_method_LCOM.png[Step 3: Merge groups with a common method]

[[count_and_assign_the_number_of_groups]]
.Count the remaining groups and assign the result to a property of the type.
image::04_Count_and_assign_the_number_of_groups_LCOM.png[Step 4: Count and assign the number of groups]

IMPORTANT: How to handle methods that don't read or write a field?

==== How to calculate LCOM with Neo4J?

The first two steps (<<create_a_group_for_each_field>>, <<connect_each_method_to_the_respective_group>>) are combined:

[[cohesion-metrics:LcomCreateGroups]]
.Creates a group for each field and assigns the field to the group and the group to the class.
[source,cypher,role=concept]
----
MATCH (c:Java:Class)-[:DECLARES]->(f:Field) WHERE f.static IS NULL
WITH c, collect(f) AS fields
OPTIONAL MATCH (c)-[:DECLARES]->(m:Method) WHERE m.static IS NULL
WITH c, fields, collect(m) AS methods
UNWIND fields AS field
MERGE (c)-[:HAS_GROUP]->(g:Group {name:field.name, group:true})-[:BELONGS_TO]->(field)
WITH c, methods, field, g
UNWIND methods AS method
MATCH (method)-[:READS|WRITES*1..]->(field)
MERGE (g)-[:BELONGS_TO]->(method)
WITH c, methods, field, g
MATCH (method)-[:INVOKES*1..]->(:Method)-[:READS|WRITES*1..]->(field)
MERGE (g)-[:BELONGS_TO]->(method)
RETURN g
----

The next step is to <<merge_groups_with_a_common_method>>.

[[cohesion-metrics:LcomMergeGroups]]
.Merges all groups that belong to one shared field or method.
[source,cypher,role=concept,requiresConcepts="cohesion-metrics:LcomCreateGroups"]
----
MATCH (c:Java:Class)-[:DECLARES]->(m:Method) WHERE m.static IS NULL
WITH c, collect(m) AS methods
UNWIND methods AS method
MATCH path=(g1:Group)-[:BELONGS_TO]->(method)<-[:BELONGS_TO]-(g2:Group) WHERE g1<>g2
WITH c, methods, filter(aNode IN nodes(path) WHERE aNode.group = true) AS groups
CALL apoc.refactor.mergeNodes(groups, {properties:"combine", mergeRels:true}) YIELD node
RETURN c
----

TODO: Delete duplicate relationships! Necessary?

The last step is to <<count_and_assign_the_number_of_groups>>.

[[cohesion-metrics:Lcom]]
.Counts the groups per class and sets the attribute lcom4.
[source,cypher,role=concept,requiresConcepts="cohesion-metrics:LcomMergeGroups"]
----
MATCH (c:Java:Class)-[:HAS_GROUP]->(g:Group)
WITH c, count(DISTINCT g) AS lcom
SET c.lcom = lcom
RETURN c
----


=== CohP - package level cohesion metric

Computes a package level cohesion metric

[[cohesion-metrics:CohpCreateGroups]]
.Creates a group for each type and assigns the type to the group and the group to the package.
[source,cypher,role=concept]
----
MATCH (p:Java:Package)-[:CONTAINS]->(t:Java:Type)
WITH p, collect(t) AS types
UNWIND types AS type MERGE (p)-[:HAS_GROUP]->(g:Group {name:type.name, group:true})-[:BELONGS_TO]->(type)
WITH p, g, type
MATCH (p)-[:CONTAINS]->(t:Java:Type)-[:DEPENDS_ON*1..]->(type) MERGE (g)-[:BELONGS_TO]->(t)
RETURN g
----

[[cohesion-metrics:CohpMergeGroups]]
.Merges groups with at least one shared type.
[source,cypher,role=concept,requiresConcepts="cohesion-metrics:CohpCreateGroups"]
----
MATCH (p:Java:Package)-[:CONTAINS]->(t:Java:Type)
WITH p, collect(t) AS types
UNWIND types AS type
MATCH path=(g1:Group)-[:BELONGS_TO]->(type)<-[:BELONGS_TO]-(g2:Group) WHERE g1<>g2
WITH p, types, filter(aNode in nodes(path) WHERE aNode.group = true) AS groups
CALL apoc.refactor.mergeNodes(groups, {properties:"combine", mergeRels:true}) YIELD node
RETURN p
----

[[cohesion-metrics:Cohp]]
.Counts groups per package and sets the attribute cohp.
[source,cypher,role=concept,requiresConcepts="cohesion-metrics:CohpMergeGroups"]
----
MATCH (p:Java:Package)-[:HAS_GROUP]->(g:Group)
WITH p, count(DISTINCT g) AS cohp
SET p.cohp = cohp
RETURN p
----

=== Resources

1. abc
